<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>配置解析</title>
    <!-- 网页标签页图标设置 - 支持多种格式以确保最佳兼容性 -->
    <link rel="icon" href="assets/icon.svg" type="image/svg+xml">
    <link rel="icon" href="assets/icon-32.png" type="image/png" sizes="32x32">
    <link rel="icon" href="assets/icon-16.png" type="image/png" sizes="16x16">
    <link rel="shortcut icon" href="assets/icon-32.png" type="image/png">
    <link rel="apple-touch-icon" href="assets/icon-256.png" sizes="256x256">
    <!-- 阻止浏览器自动请求默认favicon.ico（放在最后作为fallback） -->
    <link rel="icon" href="data:," type="image/x-icon">
    <style>
        body {
            font-family: 'Arial', 'Microsoft YaHei', sans-serif;
            margin: 0;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            max-width: 2200px;
            margin: 0 auto;
            width: 100%; /* 确保容器占满可用宽度 */
        }
        .header {
            background: white;
            padding: 20px 25px;
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            width: 100%; /* 确保与容器同宽 */
            box-sizing: border-box;
        }
        .header h1 {
            margin: 0 0 8px 0;
            font-size: 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .header p {
            margin: 0;
            color: #6c757d;
            font-size: 15px;
        }
        .input-section {
            background: white;
            padding: 20px 25px;
            border-radius: 12px;
            margin-bottom: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            width: 100%; /* 确保与容器同宽 */
            box-sizing: border-box;
        }
        .input-section h2 {
            margin: 0 0 15px 0;
            font-size: 20px;
            color: #343a40;
        }
        .input-section h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #495057;
        }
        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
            margin-bottom: 0;
        }
        .content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            max-width: 2200px; /* 限制最大宽度 */
            width: 100%; /* 确保占满可用宽度 */
            margin: 0 auto; /* 居中对齐 */
        }
        .visualization-container {
            background: #fff;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.12);
            border: 1px solid #e9ecef;
            min-height: 500px; /* 与右侧面板保持一致 */
            max-height: 90vh; /* 最大高度不超过视窗高度的90% */
            overflow: hidden; /* 隐藏滚动条 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .visualization-container h2 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 20px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: space-between; /* 标题和控制区分布在两端 */
            gap: 8px;
        }
        .visualization-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .controls {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 8px 12px; /* 减小内边距 */
            border-radius: 8px; /* 减小圆角 */
            margin: 0; /* 移除外边距 */
            display: flex;
            gap: 10px; /* 减小间距 */
            align-items: center;
            flex-wrap: nowrap; /* 不换行 */
            border: 1px solid rgba(255,255,255,0.3);
            font-size: 12px; /* 减小字体 */
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 6px; /* 减小间距 */
        }
        .control-group label {
            font-size: 11px; /* 减小标签字体 */
            color: #495057;
            white-space: nowrap;
        }
        #opacityValue {
            font-size: 11px;
            color: #495057;
            min-width: 30px;
        }
        .toggle-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 6px 10px; /* 减小按钮尺寸 */
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px; /* 减小字体 */
            transition: background 0.3s;
            white-space: nowrap; /* 防止文字换行 */
        }
        .toggle-btn:hover {
            background: #0056b3;
        }
        .toggle-btn.active {
            background: #28a745;
        }
        .opacity-slider {
            width: 80px; /* 减小滑块宽度 */
            margin: 0 6px; /* 减小边距 */
        }
        .file-upload {
            padding: 15px;
            border: 2px dashed #e9ecef;
            border-radius: 10px;
            text-align: center;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            transition: all 0.3s ease;
            position: relative; /* 为粘贴提示定位 */
        }
        .file-upload:hover {
            border-color: #667eea;
            background: linear-gradient(135deg, #f0f2ff 0%, #e8ebff 100%);
        }
        .file-upload.paste-ready {
            border-color: #28a745;
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            box-shadow: 0 0 10px rgba(40, 167, 69, 0.3);
        }
        .file-upload .paste-hint {
            position: absolute;
            top: 5px;
            right: 10px;
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .file-upload.paste-ready .paste-hint {
            opacity: 1;
        }
        .file-upload p {
            margin: 0 0 8px 0;
            font-size: 14px;
            color: #495057;
        }
        .file-upload p:last-of-type {
            margin: 8px 0 0 0;
            font-size: 12px;
            color: #6c757d;
        }
        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        .json-input {
            width: 100%;
            height: 120px;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            background: #f8f9fa;
            transition: border-color 0.3s ease;
        }
        .json-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .parse-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            margin-top: 12px;
            width: 100%;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(40, 167, 69, 0.4);
        }
        .parse-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(40, 167, 69, 0.6);
        }
        .parse-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 6px;
            margin-top: 8px;
            border: 1px solid #f5c6cb;
            font-size: 13px;
        }
        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 6px;
            margin-top: 8px;
            border: 1px solid #c3e6cb;
            font-size: 13px;
        }
        .layer-list {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 12px;
            margin: 15px 0 0 0; /* 移除底部边距 */
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            flex: 1; /* 占用剩余空间 */
            overflow-y: auto; /* 列表内容可滚动 */
        }
        .config-group-header {
            background: #f8f9fa;
            padding: 15px 20px;
            font-weight: bold;
            color: #343a40;
            border-bottom: 1px solid #dee2e6;
            font-size: 17px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .config-group-header .group-icon {
            width: 18px;
            height: 18px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 11px;
            font-weight: bold;
        }
        .config-group-header.douyin {
            background: #e8f4fd;
            color: #0c5aa6;
            border-left: 4px solid #0c5aa6;
        }
        .config-group-header.obs {
            background: #f0e8fd;
            color: #6b2c91;
            border-left: 4px solid #6b2c91;
        }
        .config-group-header .group-icon.douyin-icon {
            background: #0c5aa6;
        }
        .config-group-header .group-icon.obs-icon {
            background: #6b2c91;
        }
        .layer-item {
            padding: 15px 20px 15px 35px;
            border-bottom: 1px solid #dee2e6;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
        }
        .layer-item::before {
            content: '';
            position: absolute;
            left: 20px;
            width: 3px;
            height: 50%;
            background: #dee2e6;
            top: 0;
        }
        .layer-item::after {
            content: '';
            position: absolute;
            left: 20px;
            top: 50%;
            width: 12px;
            height: 3px;
            background: #dee2e6;
        }
        .layer-item:last-child::before {
            height: 50%;
        }
        .layer-item.show-all {
            padding: 15px 20px;
            background: linear-gradient(135deg, #cff4fc 0%, #b6effb 100%);
            font-weight: bold;
            color: #055160;
            border-radius: 12px 12px 0 0;
        }
        .layer-item.show-all::before,
        .layer-item.show-all::after {
            display: none;
        }
        .layer-item.show-all.selected {
            background: linear-gradient(135deg, #b6effb 0%, #9fecfa 100%);
            border-left: 4px solid #0dcaf0;
        }
        .layer-item:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
        }
        .layer-item.selected {
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            border-left: 4px solid #28a745;
        }
        .layer-color-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .layer-text {
            flex: 1;
            font-size: 16px;
            line-height: 1.5;
        }
        .layer-title {
            font-weight: bold;
            color: #212529;
            font-size: 16px;
        }
        .layer-desc {
            color: #6c757d;
            font-size: 14px;
            margin-top: 4px;
        }
        .instructions {
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #28a745;
            border: 1px solid rgba(40, 167, 69, 0.2);
        }
        .instructions h3 {
            margin: 0 0 10px 0;
            color: #155724;
            font-size: 16px;
        }
        .instructions ul {
            margin: 0;
            padding-left: 20px;
            color: #155724;
            font-size: 14px;
            line-height: 1.6;
        }
        .placeholder-message {
            text-align: center;
            color: #6c757d;
            padding: 30px;
            font-style: italic;
            font-size: 14px;
        }
        .layer-item:last-child {
            border-bottom: none;
        }
        .config-group-header + .layer-item:first-of-type::before {
            top: 50%;
            height: 50%;
        }
        .resource-features {
            width: 100%;
            background: #fff;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.12);
            border: 1px solid #e9ecef;
            overflow-x: auto; /* 表格超宽时水平滚动 */
            box-sizing: border-box; /* 确保padding不影响宽度 */
        }
        .resource-features h2 {
            margin: 0 0 20px 0;
            color: #333;
            font-size: 22px; /* 从20px增加到22px */
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .resource-table {
            width: 100%;
            border-collapse: collapse;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            table-layout: fixed; /* 固定表格布局，确保列宽均匀分布 */
        }
        .resource-table th {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 2px; /* 减少左右内边距，减少留白 */
            text-align: center;
            font-weight: bold;
            font-size: 15px; /* 从13px增加到15px */
            word-wrap: break-word;
            height: 40px; /* 设置表头高度 */
            vertical-align: middle;
        }
        .resource-table td {
            padding: 8px 2px; /* 减少左右内边距，减少留白 */
            text-align: center;
            border-bottom: 1px solid #e9ecef;
            background: #fff;
            font-size: 14px; /* 从12px增加到14px */
            word-wrap: break-word;
            overflow: hidden;
            height: 50px; /* 设置双行行高 */
            vertical-align: middle;
        }
        .resource-table tr:last-child td {
            border-bottom: none;
        }
        .resource-table .process-type {
            font-weight: bold;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            color: #495057;
            width: 8%; /* 改为百分比，确保一致性 */
            min-width: 80px; /* 设置最小宽度 */
        }
        .resource-table .process-name {
            font-family: 'Courier New', monospace;
            color: #000000; /* 改为更深的黑色 */
            overflow: hidden;
            white-space: normal; /* 允许换行 */
            word-break: break-word; /* 长单词可以换行 */
            font-size: 15px; /* 从13px增加到15px */
            padding: 4px 1px; /* 减少左右内边距，减少留白 */
            line-height: 1.2; /* 设置行高 */
        }
        .resource-table .process-tag {
            color: #6c757d;
            font-style: normal; /* 移除斜体 */
            padding: 0; /* 移除内边距 */
        }
        .resource-table .process-tag .process-tag-badge {
            font-size: 13px !important; /* 从11px增加到13px */
            padding: 3px 5px !important; /* 适当增加标签内边距 */
        }
        .resource-table .process-percentage {
            font-weight: bold;
            color: #e74c3c;
            font-size: 14px; /* 从12px增加到14px */
        }
        .resource-table .process-empty {
            color: #adb5bd;
            font-style: italic;
            background: #f8f9fa;
        }
        
        /* 响应式设计：当屏幕较小时，使用水平滚动 */
        .resource-features {
            overflow-x: auto;
        }
        
        /* 当有5个进程时的特殊样式 */
        .resource-table.five-processes th,
        .resource-table.five-processes td {
            padding: 6px 1px; /* 减少左右内边距，减少留白 */
            font-size: 13px; /* 从11px增加到13px */
        }
        
        .resource-table.five-processes .process-name {
            font-size: 14px; /* 从12px增加到14px */
        }
        
        .resource-table.five-processes .process-tag .process-tag-badge {
            font-size: 12px !important; /* 从10px增加到12px */
            padding: 2px 4px !important;
        }
        .resource-features .empty-state {
            text-align: center;
            color: #6c757d;
            padding: 40px 20px;
            font-style: italic;
        }
        .layer-panel-container {
            display: grid;
            grid-template-columns: 3fr 2fr; /* 改为固定的3:2比例 */
            gap: 20px;
            width: 100%; /* 确保占满容器宽度 */
            box-sizing: border-box;
            align-items: stretch; /* 改为拉伸对齐，确保等高 */
            min-height: 500px; /* 增加最小高度 */
            max-height: 90vh; /* 最大高度 */
        }
        .layer-panel {
            background: #fff;
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.12);
            border: 1px solid #e9ecef;
            min-height: 500px; /* 与左侧面板保持一致 */
            max-height: 90vh; /* 最大高度不超过视窗高度的90% */
            overflow-y: auto; /* 内容超出时滚动 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }
        .layer-panel h2 {
            margin: 0 0 15px 0;
            font-size: 22px;
            color: #343a40;
        }
        .layer-panel p {
            margin: 0 0 20px 0;
            font-size: 16px;
            color: #6c757d;
        }
        .game-image-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 3px solid #667eea;
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0 0 0; /* 移除底部边距 */
            background: transparent; /* 改为透明背景 */
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.2);
            flex: 1; /* 占用剩余空间 */
            min-height: 300px; /* 最小高度 */
            width: 100%;
            height: 100%;
        }
        .game-image {
            display: block;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain; /* 保持宽高比，完整显示 */
            object-position: center; /* 居中显示 */
            opacity: 0.9;
        }
        .layer-overlays {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* 允许点击穿透到图片 */
        }
        .layer-overlay {
            position: absolute;
            border: 6px dashed; /* 改为虚线边框 */
            opacity: 0.7; /* 增加透明度 */
            transition: all 0.3s ease;
            cursor: pointer;
            pointer-events: auto; /* 恢复叠加层的点击事件 */
            box-shadow: 0 0 10px rgba(0,0,0,0.5); /* 添加阴影增强可见性 */
        }
        .layer-overlay:hover {
            opacity: 1;
            border-style: dashed; /* 悬停时也保持虚线 */
            border-width: 8px; /* 悬停时进一步增加边框宽度 */
            z-index: 100;
            box-shadow: 0 0 15px rgba(0,0,0,0.7); /* 悬停时增强阴影 */
        }
        .layer-overlay.hidden {
            display: none;
        }
        .layer-label {
            position: absolute;
            color: white; /* 默认白色，会被JavaScript动态设置 */
            font-size: 16px; /* 增加字体大小提高可见性 */
            font-weight: bold;
            padding: 4px 6px; /* 减少内边距 */
            white-space: nowrap;
            text-shadow: 
                2px 2px 4px rgba(0,0,0,1), 
                -1px -1px 2px rgba(0,0,0,1),
                1px -1px 2px rgba(0,0,0,1),
                -1px 1px 2px rgba(0,0,0,1); /* 增强文字阴影，四个方向都有阴影 */
            z-index: 10;
            /* 移除背景色、边框和模糊效果，保持透明 */
        }
        .layer-details {
            position: fixed; /* 改为固定定位 */
            top: 50%; /* 垂直居中 */
            left: 50%; /* 水平居中 */
            transform: translate(-50%, -50%); /* 精确居中 */
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 20px; /* 增加内边距 */
            font-size: 14px; /* 增大字体 */
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 8px; /* 增加圆角 */
            box-shadow: 0 4px 20px rgba(0,0,0,0.5); /* 添加阴影 */
            z-index: 1000; /* 确保在最上层 */
            max-width: 400px; /* 限制最大宽度 */
            min-width: 250px; /* 设置最小宽度 */
            pointer-events: none; /* 防止阻挡鼠标事件 */
        }
        .layer-overlay:hover .layer-details {
            opacity: 1;
        }
        
        /* 隐藏类样式 */
        .hidden {
            display: none !important;
        }
        
        /* 全局详细信息显示区域 */
        .global-layer-details {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 15px 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
            z-index: 1000;
            max-width: 400px; /* 设置合理的最大宽度 */
            min-width: auto; /* 移除最小宽度限制 */
            width: auto; /* 自适应宽度 */
            pointer-events: none;
            display: none;
            white-space: normal; /* 允许文本换行 */
            line-height: 1.4; /* 设置行高提高可读性 */
        }
        
        .global-layer-details.show {
            opacity: 1;
            display: block;
        }
        
        /* 详细信息内部样式 */
        .global-layer-details div {
            margin-bottom: 4px; /* 行间距 */
        }
        
        .global-layer-details div:last-child {
            margin-bottom: 0; /* 最后一行不需要底部间距 */
        }
        
        /* 音量设置模块样式 - 中性色彩 */
        .audio-settings {
            margin-top: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 8px;
            border-left: 4px solid #6c757d; /* 中性灰色 */
        }
        
        .audio-settings-title {
            font-weight: bold;
            font-size: 16px;
            color: #495057; /* 中性深灰色 */
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .audio-settings-content {
            display: flex;
            flex-wrap: wrap;
            gap: 30px;
            font-size: 14px;
            color: #495057;
        }
        
        .audio-setting-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .audio-setting-label {
            font-weight: bold;
            color: #343a40;
        }
        
        .audio-setting-value {
            font-weight: bold;
            color: #6c757d; /* 中性颜色显示数值 */
            font-family: 'Courier New', monospace;
        }
        
        .audio-setting-value.muted {
            color: #dc3545; /* 静音状态用红色 */
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><img src="assets/icon.svg" alt="icon" style="width: 32px; height: 32px; margin-right: 8px; vertical-align: middle;" onerror="this.src='assets/icon-32.png'"> 配置解析</h1>
            <p>智能解析配置JSON，可视化显示各个源的位置和覆盖范围，让配置一目了然</p>
        </div>
        
        <!-- 输入区域 -->
        <div class="input-section">
            <h2>📥 输入配置</h2>
            <div class="input-grid">
                <!-- 图片上传 -->
                <div>
                    <h3>🖼️ 1. 上传底图</h3>
                    <div class="file-upload" id="fileUploadArea">
                        <div class="paste-hint">Ctrl+V 粘贴</div>
                        <p>请上传您的游戏截图或底图</p>
                        <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                        <button class="upload-btn" onclick="document.getElementById('imageUpload').click();">选择图片文件</button>
                        <p>支持 JPG, PNG, GIF 等常见图片格式<br>💡 <strong>鼠标悬停后可直接 Ctrl+V 粘贴剪贴板图片</strong></p>
                    </div>
                </div>
                
                <!-- JSON输入 -->
                <div>
                    <h3>⚙️ 2. 输入JSON配置</h3>
                    <textarea 
                        id="jsonInput" 
                        class="json-input" 
                        placeholder='请粘贴您的配置JSON，支持两种格式：

1. sourceInfo格式：
{
  "resolution": "{\"width\":1920,\"height\":1080}",
  "sourceInfo": "{\"process\":{\"sourceList\":[{\"exeName\":\"game.exe\",\"overlap\":0.25,\"canvasOverlap\":1,\"canvasOverlapRect\":[0,0,1920,1080],\"layer\":3}]}}"
}

2. obsSourceInfo格式：
{
  "resolution": "{\"width\":1920,\"height\":1080}",
  "obsSourceInfo": "{\"process\":[{\"exeName\":\"TslGame.exe\",\"pos\":{\"x\":0,\"y\":0},\"name\":\"游戏源\"}],\"video\":[{\"volume\":1,\"filepath\":\"video.mp4\",\"fileSize\":962820755,\"pos\":{\"x\":240,\"y\":90}}]}"
}'></textarea>
                    <button class="parse-btn" id="parseBtn" onclick="parseConfiguration()">🔍 解析配置</button>
                    <div id="parseMessage"></div>
                </div>
                
                <!-- 使用说明 -->
                <div>
                    <h3>💡 3. 使用说明</h3>
                    <div class="instructions">
                        <h3>✨ 快速上手</h3>
                        <ul>
                            <li>上传您的游戏截图或底图</li>
                            <li>粘贴配置的JSON代码</li>
                            <li>点击"解析配置"自动生成可视化</li>
                            <li>点击图层行查看单独效果</li>
                            <li>调节透明度和显示选项</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="content">
            <!-- 资源特征模块 -->
            <div class="resource-features" id="resourceFeatures" style="display: none;">
                <h2>🖥️ 资源特征</h2>
                <div id="resourceTableContainer">
                    <div class="empty-state">暂无资源信息，请解析包含 cpuTopProcessList 或 gpuTopProcessList 的配置</div>
                </div>
            </div>
            
            <div class="layer-panel-container">
                <div class="visualization-container">
                    <h2>
                        <div class="visualization-title">
                            🖼️ 解析预览图
                        </div>
                        <div class="controls">
                            <div class="control-group">
                                <label>🎛️ 叠加层透明度:</label>
                                <input type="range" class="opacity-slider" id="opacitySlider" min="0.2" max="1" step="0.1" value="0.7" onchange="updateOpacity(this.value)">
                                <span id="opacityValue">70%</span>
                            </div>
                            <div class="control-group">
                                <button class="toggle-btn active" id="layerToggle" onclick="toggleLayers()">显示层级叠加</button>
                                <button class="toggle-btn" onclick="toggleDetails()">显示详细信息</button>
                            </div>
                        </div>
                    </h2>
                    
                    <div class="game-image-container" id="gameContainer">
                        <img class="game-image" id="gameImage" src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTkyMCIgaGVpZ2h0PSIxMDgwIiB2aWV3Qm94PSIwIDAgMTkyMCAxMDgwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxyZWN0IHdpZHRoPSIxOTIwIiBoZWlnaHQ9IjEwODAiIGZpbGw9InRyYW5zcGFyZW50IiBzdHJva2U9IiNkZWUyZTYiIHN0cm9rZS13aWR0aD0iNCIgc3Ryb2tlLWRhc2hhcnJheT0iMjAgMTAiLz48dGV4dCB4PSI5NjAiIHk9IjU0MCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzZjNzU3ZCIgZm9udC1zaXplPSI0OCIgZm9udC1mYW1pbHk9IkFyaWFsLCBNaWNyb3NvZnQgWWFIZWksIHNhbnMtc2VyaWYiPui/memHjOS8muWxleekuuino+aekOWQjueahOekuuaEj+WbvjwvdGV4dD48L3N2Zz4K" alt="等待上传底图">
                        
                        <!-- 动态生成的层级叠加覆盖层 -->
                        <div class="layer-overlays" id="layerOverlays">
                            <!-- 这里将根据JSON动态生成层级 -->
                        </div>
                    </div>
                </div>
                
                <div class="layer-panel">
                    <h2>📋 配置图层列表</h2>
                    <p>解析JSON配置后，点击下方列表中的任意行查看对应图层</p>
                    
                    <div class="layer-list" id="layerList">
                        <div class="placeholder-message">
                            请先上传底图并输入JSON配置，然后点击"解析配置"按钮
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 全局详细信息显示区域 -->
    <div class="global-layer-details" id="globalLayerDetails"></div>

    <script>
        let currentSelectedLayer = 'all';
        let parsedLayers = [];
        let canvasResolution = { width: 1920, height: 1080 };
        let processLibrary = []; // 进程库数据
        
        // 标签颜色样式配置
        const tagStyles = {
            '游戏进程': { background: '#40c057', color: '#000000' }, // 调浅绿色底色
            '浏览器进程': { background: '#007bff', color: '#ffffff' }, // 蓝色
            '视频播放器进程': { background: '#6f42c1', color: '#ffffff' }, // 紫色
            '手机投屏进程': { background: '#fd7e14', color: '#ffffff' }, // 橙色
            '安卓模拟器': { background: '#20c997', color: '#ffffff' }, // 青色
            '串流作弊进程': { background: '#dc3545', color: '#ffffff' }, // 红色
            '弹幕爬取进程': { background: '#ffc107', color: '#000000' }, // 黄色，黑字
            '人机校验作弊进程': { background: '#6c757d', color: '#ffffff' }, // 灰色
            '音频录制AI互动进程': { background: '#e83e8c', color: '#ffffff' }, // 粉色
            '自动操作脚本': { background: '#795548', color: '#ffffff' }, // 棕色
            '游戏外挂作弊': { background: '#8b0000', color: '#ffffff' }, // 深红色
            '伴侣进程': { background: '#17a2b8', color: '#ffffff' }, // 蓝绿色
            '私服进程': { background: '#ff5722', color: '#ffffff' }, // 深橙色
            '盗号进程': { background: '#9c27b0', color: '#ffffff' }, // 深紫色
            '黑产进程': { background: '#212529', color: '#ffffff' }, // 深黑色
            '非脚本进程': { background: '#607d8b', color: '#ffffff' }, // 蓝灰色
            '未知进程': { background: '#adb5bd', color: '#000000' } // 浅灰色，黑字
        };
        
        // 页面加载时加载进程库
        window.addEventListener('load', function() {
            loadProcessLibrary();
        });
        
        // 加载进程库CSV文件
        async function loadProcessLibrary() {
            try {
                const response = await fetch('process-library.csv');
                const csvText = await response.text();
                parseCSV(csvText);
                console.log(`进程库加载成功，共 ${processLibrary.length} 条记录`);
            } catch (error) {
                console.warn('进程库加载失败:', error);
                // 即使加载失败也不影响主要功能
            }
        }
        
        // 解析CSV数据
        function parseCSV(csvText) {
            const lines = csvText.trim().split('\n');
            
            processLibrary = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue; // 跳过空行
                
                const values = line.split(',');
                if (values.length >= 2 && values[0].trim() && values[1].trim()) {
                    processLibrary.push({
                        exe: values[0].trim(),
                        type: values[1].trim()
                    });
                }
            }
        }
        
        // 进程名模糊匹配 - 返回所有匹配的标签 - 修复版本
        function matchProcessType(processName) {
            if (!processName || !isProcessLibraryLoaded) {
                console.log('匹配失败: processName =', processName, ', isProcessLibraryLoaded =', isProcessLibraryLoaded);
                return ['未知进程'];
            }
            
            // 移除.exe后缀进行匹配，转换为小写
            const cleanProcessName = processName.toLowerCase().replace(/\.exe$/, '');
            console.log('匹配进程:', processName, '→', cleanProcessName);
            
            // 直接在processLabelMap中查找
            if (processLabelMap[cleanProcessName]) {
                const label = processLabelMap[cleanProcessName];
                console.log('精确匹配成功:', cleanProcessName, '→', label);
                return [label];
            }
            
            // 如果精确匹配失败，尝试模糊匹配
            const fuzzyMatches = Object.keys(processLabelMap).filter(key => 
                cleanProcessName.includes(key) || key.includes(cleanProcessName)
            );
            
            if (fuzzyMatches.length > 0) {
                const matchedTypes = fuzzyMatches.map(key => processLabelMap[key]);
                console.log('模糊匹配成功:', fuzzyMatches, '→', matchedTypes);
                return [...new Set(matchedTypes)]; // 去重
            }
            
            console.log('匹配失败，进程库中的相关键:', Object.keys(processLabelMap).filter(key => 
                key.includes('microsoft') || key.includes('media') || key.includes('player')
            ));
            
            return ['未知进程'];
        }
        
        // 生成标签HTML - 支持多个标签
        function generateTagHTML(tagTypes) {
            // 如果是字符串，转换为数组
            if (typeof tagTypes === 'string') {
                tagTypes = [tagTypes];
            }
            
            return tagTypes.map(tagType => {
                const style = tagStyles[tagType] || { background: '#6c757d', color: '#ffffff' };
                return `<span class="process-tag-badge" style="background: ${style.background}; color: ${style.color}; padding: 3px 5px; border-radius: 12px; font-size: 13px; font-family: 'Microsoft YaHei', sans-serif; font-weight: 500; white-space: nowrap; display: inline-block; margin-right: 4px;">${tagType}</span>`;
            }).join('');
        }
        
        // 层级颜色映射 - 扩展到50种鲜明易分辨的颜色
        const layerColors = [
            '#FF0080', // 鲜艳的粉红色
            '#00FF00', // 鲜绿色
            '#FF4500', // 橙红色
            '#00BFFF', // 深天蓝色
            '#FF1493', // 深粉红色
            '#32CD32', // 酸橙绿
            '#FFD700', // 金色
            '#FF6347', // 番茄红
            '#00CED1', // 深绿松石色
            '#DA70D6', // 兰花紫
            '#FF8C00', // 深橙色
            '#7FFF00', // 查特酒绿
            '#DC143C', // 深红色
            '#00FFFF', // 青色
            '#FF69B4', // 热粉红色
            '#ADFF2F', // 绿黄色
            '#FF4444', // 亮红色
            '#44FF44', // 亮绿色
            '#4444FF', // 亮蓝色
            '#FFFF44', // 亮黄色
            '#FF44FF', // 亮洋红色
            '#44FFFF', // 亮青色
            '#FF8844', // 亮橙色
            '#88FF44', // 亮黄绿色
            '#4488FF', // 亮蓝紫色
            '#FF4488', // 亮玫瑰色
            '#88FF88', // 亮薄荷绿
            '#8844FF', // 亮紫色
            '#FFAA44', // 亮桃色
            '#44FFAA', // 亮春绿色
            '#AA44FF', // 亮紫罗兰色
            '#FF44AA', // 亮粉紫色
            '#AAFF44', // 亮柠檬绿
            '#44AAFF', // 亮天蓝色
            '#FF6600', // 深橙色
            '#6600FF', // 深紫色
            '#00FF66', // 深春绿色
            '#FF0066', // 深玫瑰色
            '#66FF00', // 深黄绿色
            '#0066FF', // 深蓝色
            '#FF3366', // 深粉红色
            '#33FF66', // 深薄荷绿
            '#6633FF', // 深蓝紫色
            '#FF6633', // 深珊瑚色
            '#66FF33', // 深柠檬绿
            '#3366FF', // 深钴蓝色
            '#FF9933', // 深金橙色
            '#33FF99', // 深海绿色
            '#9933FF', // 深紫罗兰色
            '#FF3399'  // 深洋红色
        ];

        // 统一的颜色获取函数
        function getLayerColor(layerIndex) {
            if (layerIndex < layerColors.length) {
                return layerColors[layerIndex];
            }
            // 如果超出预定义颜色数量，使用循环模式
            return layerColors[layerIndex % layerColors.length];
        }

        // 源类型中文映射 - 扩展版本
        const sourceTypeNames = {
            'camera': '摄像头',
            'captureCard': '采集卡',
            'process': '进程',
            'text': '文本',
            'screenshot': '截图',
            'video': '视频',
            'image': '图片',
            'fullscreen': '显示器投屏',
            'audio': '音频',
            'microphone': '麦克风',
            'desktop': '桌面',
            'window': '窗口',
            'browser': '浏览器',
            'media': '媒体',
            'stream': '流媒体',
            'overlay': '叠加层',
            'filter': '滤镜',
            'transition': '转场',
            'scene': '场景',
            'iosWirelessProjection': '手机投屏'
        };

        // 图片上传处理
        document.getElementById('imageUpload').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('gameImage').src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // 剪贴板粘贴图片功能
        const fileUploadArea = document.getElementById('fileUploadArea');
        let isHoveringUploadArea = false;

        // 鼠标悬停状态管理
        fileUploadArea.addEventListener('mouseenter', function() {
            isHoveringUploadArea = true;
            fileUploadArea.classList.add('paste-ready');
        });

        fileUploadArea.addEventListener('mouseleave', function() {
            isHoveringUploadArea = false;
            fileUploadArea.classList.remove('paste-ready');
        });

        // 全局粘贴事件监听
        document.addEventListener('paste', function(e) {
            // 只有在悬停上传区域时才处理粘贴
            if (!isHoveringUploadArea) {
                return;
            }

            const items = e.clipboardData.items;
            let imageFile = null;

            // 查找剪贴板中的图片
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.type.indexOf('image') !== -1) {
                    imageFile = item.getAsFile();
                    break;
                }
            }

            if (imageFile) {
                e.preventDefault(); // 阻止默认粘贴行为
                
                // 显示粘贴成功的视觉反馈
                fileUploadArea.style.borderColor = '#28a745';
                fileUploadArea.style.background = 'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)';
                
                // 读取并显示图片
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById('gameImage').src = e.target.result;
                    
                    // 显示成功消息
                    showMessage('✅ 成功从剪贴板粘贴图片！', 'success');
                    
                    // 恢复原始样式
                    setTimeout(() => {
                        if (isHoveringUploadArea) {
                            fileUploadArea.style.borderColor = '#28a745';
                            fileUploadArea.style.background = 'linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%)';
                        } else {
                            fileUploadArea.style.borderColor = '';
                            fileUploadArea.style.background = '';
                        }
                    }, 500);
                };
                reader.readAsDataURL(imageFile);
                
                console.log('从剪贴板粘贴图片成功:', imageFile.name || '未命名图片', '大小:', imageFile.size, 'bytes');
            } else {
                // 剪贴板中没有图片时的提示
                if (e.clipboardData.items.length > 0) {
                    showMessage('⚠️ 剪贴板中没有图片，请先复制图片后再粘贴', 'error');
                }
            }
        });

        // 键盘快捷键提示
        document.addEventListener('keydown', function(e) {
            if (isHoveringUploadArea && e.ctrlKey && e.key === 'v') {
                // 显示粘贴动画效果
                fileUploadArea.style.transform = 'scale(1.02)';
                setTimeout(() => {
                    fileUploadArea.style.transform = '';
                }, 150);
            }
        });

        // 解析JSON配置
        async function parseConfiguration() {
            const jsonInput = document.getElementById('jsonInput').value.trim();
            const messageDiv = document.getElementById('parseMessage');
            
            if (!jsonInput) {
                showMessage('请输入JSON配置代码', 'error');
                return;
            }

            console.log('🔍 开始解析JSON，输入长度:', jsonInput.length);
            console.log('🔍 输入的前100个字符:', jsonInput.substring(0, 100));

            try {
                let data;
                
                // 检查是否为转义的JSON字符串格式
                if (jsonInput.startsWith('"{') && jsonInput.endsWith('}"')) {
                    console.log('🔍 检测到转义JSON格式，进行双重解析');
                    try {
                        // 先解析外层字符串
                        const unescapedJson = JSON.parse(jsonInput);
                        console.log('🔍 第一次解析结果:', unescapedJson.substring(0, 100));
                        // 再解析内层JSON
                        data = JSON.parse(unescapedJson);
                        console.log('🔍 转义JSON解析成功');
                    } catch (escapeErr) {
                        console.log('🔍 转义JSON解析失败，尝试标准解析:', escapeErr.message);
                        data = JSON.parse(jsonInput);
                    }
                } else {
                    // 尝试直接解析
                    data = JSON.parse(jsonInput);
                    console.log('🔍 标准JSON解析成功');
                }
                
                await parseSuccessfulData(data);
                
            } catch (err) {
                console.log('🔍 直接解析失败，尝试容错修复:', err.message);
                
                // 尝试容错解析
                try {
                    const fixedJson = fixJsonErrors(jsonInput);
                    console.log('🔍 容错修复后的JSON:', fixedJson.substring(0, 200));
                    const data = JSON.parse(fixedJson);
                    
                    showMessage(`⚠️ JSON格式有误，已自动修复并成功解析！`, 'success');
                    await parseSuccessfulData(data);
                    
                } catch (fixErr) {
                    console.error('🔍 容错解析也失败:', fixErr.message);
                    showMessage(`❌ JSON解析失败: ${err.message}。尝试自动修复后仍然失败: ${fixErr.message}`, 'error');
                    clearVisualization();
                    // 隐藏资源特征模块
                    document.getElementById('resourceFeatures').style.display = 'none';
                }
            }
        }

        // JSON容错修复函数
        function fixJsonErrors(jsonStr) {
            let fixed = jsonStr;
            
            console.log('开始JSON容错修复...');
            
            // 1. 修复开头缺少双引号的问题
            // 匹配 {字母 而不是 {"字母
            fixed = fixed.replace(/^(\s*\{)([a-zA-Z_][a-zA-Z0-9_]*")/g, '$1"$2');
            
            // 2. 修复属性名缺少双引号的问题
            // 匹配 ,字母: 或 {字母: 而不是 ,"字母": 或 {"字母":
            fixed = fixed.replace(/([,{]\s*)([a-zA-Z_][a-zA-Z0-9_]*)(\s*:)/g, '$1"$2"$3');
            
            // 3. 修复多余的反斜杠问题
            // 将 \\\\\\\\替换为 \\\\
            fixed = fixed.replace(/\\\\\\\\/g, '\\\\');
            
            // 4. 修复缺少逗号的问题
            // 在 }" 和 "字母 之间添加逗号
            fixed = fixed.replace(/("\s*})\s*(")/g, '$1,$2');
            
            // 5. 修复多余逗号的问题
            // 移除 ,} 和 ,] 中的多余逗号
            fixed = fixed.replace(/,(\s*[}\]])/g, '$1');
            
            // 6. 修复未闭合的引号
            // 这个比较复杂，先处理简单情况
            
            // 7. 修复缺少结束括号的问题
            const openBraces = (fixed.match(/\{/g) || []).length;
            const closeBraces = (fixed.match(/\}/g) || []).length;
            if (openBraces > closeBraces) {
                fixed += '}';
                console.log('添加了缺少的结束括号');
            }
            
            // 8. 修复缺少开始括号的问题
            if (closeBraces > openBraces) {
                fixed = '{' + fixed;
                console.log('添加了缺少的开始括号');
            }
            
            console.log('JSON修复完成');
            return fixed;
        }

        // 解析成功后的数据处理
        async function parseSuccessfulData(data) {
            console.log('🔍 开始解析数据，原始数据结构:', data);
            console.log('🔍 数据的所有键:', Object.keys(data));
            
            // 字段名标准化：将cpuTopProcess转换为cpuTopProcessList，gpuTopProcess转换为gpuTopProcessList
            if (data.cpuTopProcess && !data.cpuTopProcessList) {
                console.log('检测到cpuTopProcess字段，转换为cpuTopProcessList');
                data.cpuTopProcessList = data.cpuTopProcess;
                delete data.cpuTopProcess; // 删除原字段避免重复处理
            }
            
            if (data.gpuTopProcess && !data.gpuTopProcessList) {
                console.log('检测到gpuTopProcess字段，转换为gpuTopProcessList');
                data.gpuTopProcessList = data.gpuTopProcess;
                delete data.gpuTopProcess; // 删除原字段避免重复处理
            }
                
                // 解析resolution
                if (data.resolution) {
                console.log('🔍 找到resolution字段:', data.resolution);
                    canvasResolution = JSON.parse(data.resolution);
                console.log('🔍 解析后的分辨率:', canvasResolution);
            } else {
                console.log('⚠️ 未找到resolution字段，使用默认分辨率');
                }
                
                // 收集所有图层
                parsedLayers = [];
                
                // 处理sourceInfo格式
                if (data.sourceInfo) {
                console.log('🔍 找到sourceInfo字段:', data.sourceInfo);
                try {
                    const sourceInfoData = JSON.parse(data.sourceInfo);
                    console.log('🔍 解析后的sourceInfo:', sourceInfoData);
                    parseSourceInfo(sourceInfoData);
                    console.log('🔍 sourceInfo解析完成，当前图层数:', parsedLayers.length);
                } catch (e) {
                    console.error('❌ sourceInfo解析失败:', e);
                }
            } else {
                console.log('⚠️ 未找到sourceInfo字段');
                }
                
                // 处理obsSourceInfo格式
                if (data.obsSourceInfo) {
                console.log('🔍 找到obsSourceInfo字段:', data.obsSourceInfo);
                try {
                    const obsSourceInfoData = JSON.parse(data.obsSourceInfo);
                    console.log('🔍 解析后的obsSourceInfo:', obsSourceInfoData);
                    parseObsSourceInfo(obsSourceInfoData);
                    console.log('🔍 obsSourceInfo解析完成，当前图层数:', parsedLayers.length);
                } catch (e) {
                    console.error('❌ obsSourceInfo解析失败:', e);
                }
            } else {
                console.log('⚠️ 未找到obsSourceInfo字段');
            }
            
            // 处理资源特征数据 - 现在只需要检查List格式
                let hasResourceData = false;
                if (data.cpuTopProcessList || data.gpuTopProcessList || data.pcSpeakerDecibel || data.micDecibleList) {
                console.log('🔍 找到资源特征数据');
                console.log('🔍 cpuTopProcessList:', data.cpuTopProcessList ? '存在' : '不存在');
                console.log('🔍 gpuTopProcessList:', data.gpuTopProcessList ? '存在' : '不存在');
                console.log('🔍 pcSpeakerDecibel:', data.pcSpeakerDecibel !== undefined ? '存在' : '不存在');
                console.log('🔍 micDecibleList:', data.micDecibleList ? '存在' : '不存在');
                await generateResourceFeatures(data);
                    hasResourceData = true;
            } else {
                console.log('⚠️ 未找到资源特征数据 (cpuTopProcessList, gpuTopProcessList, pcSpeakerDecibel, micDecibleList)');
                }
                
                // 显示或隐藏资源特征模块
                const resourceFeatures = document.getElementById('resourceFeatures');
                if (hasResourceData) {
                    resourceFeatures.style.display = 'block';
                } else {
                    resourceFeatures.style.display = 'none';
                }
                
            console.log('🔍 最终解析结果:');
            console.log('🔍 图层数量:', parsedLayers.length);
            console.log('🔍 资源特征数据:', hasResourceData ? '有' : '无');
            console.log('🔍 解析的图层:', parsedLayers);
            
            if (parsedLayers.length === 0 && !hasResourceData) {
                console.error('❌ 解析失败详情:');
                console.error('❌ 输入数据的所有字段:', Object.keys(data));
                console.error('❌ 期望的字段: sourceInfo, obsSourceInfo, cpuTopProcessList, gpuTopProcessList');
                console.error('❌ 实际找到的字段:', Object.keys(data).filter(key => 
                    ['sourceInfo', 'obsSourceInfo', 'cpuTopProcessList', 'gpuTopProcessList'].includes(key)
                ));
                throw new Error('未找到可解析的图层信息或资源特征数据，请检查JSON格式。期望的字段: sourceInfo, obsSourceInfo, cpuTopProcessList, gpuTopProcessList');
                }
                
                // 按layer排序
                parsedLayers.sort((a, b) => a.layer - b.layer);
                
            if (parsedLayers.length === 0) {
                showMessage(`✅ 成功解析配置！发现资源特征数据`, 'success');
            } else {
                showMessage(`✅ 成功解析配置！发现 ${parsedLayers.length} 个图层${hasResourceData ? '和资源特征数据' : ''}`, 'success');
            }
                
                // 生成可视化
                generateVisualization();
                generateLayerList();
        }

        // 解析sourceInfo格式
        function parseSourceInfo(sourceInfo) {
            Object.keys(sourceInfo).forEach(sourceType => {
                // 过滤掉pipe源，不进行解析
                if (sourceType === 'pipe') {
                    console.log('过滤掉pipe源，不进行展示');
                    return;
                }
                
                const sourceData = sourceInfo[sourceType];
                if (sourceData.sourceList) {
                    sourceData.sourceList.forEach(source => {
                        parsedLayers.push({
                            ...source,
                            sourceType,
                            configSource: 'douyin', // 标识来源为伴侣
                            name: source.name || source.exeName || source.fileName || `${sourceTypeNames[sourceType] || sourceType}源`
                        });
                    });
                }
            });
        }

        // 解析obsSourceInfo格式 - 通用版本
        function parseObsSourceInfo(obsSourceInfo) {
            let layerIndex = 0;
            
            // 检测分辨率模式
            const detectedResolution = detectResolutionMode(obsSourceInfo);
            
            // 遍历所有配置类型，通用处理
            Object.keys(obsSourceInfo).forEach(sourceType => {
                // 跳过特殊字段
                if (['otherScenes', 'auxAudioVolumn', 'desktopAudioVolumn'].includes(sourceType)) {
                    console.log(`跳过特殊字段: ${sourceType}`);
                    return;
                }
                
                const sourceData = obsSourceInfo[sourceType];
                
                // 检查是否为数组格式的源配置
                if (Array.isArray(sourceData)) {
                    console.log(`处理源类型: ${sourceType}, 数量: ${sourceData.length}`);
                    
                    sourceData.forEach(source => {
                        // 检查是否有位置信息
                        if (source.pos && typeof source.pos === 'object') {
                            // 计算图层的宽度和高度
                            let obsLayerWidth, obsLayerHeight;
                            
                            if (detectedResolution.needsScaling) {
                                // 超出范围的情况，使用推断的原始分辨率计算
                                obsLayerWidth = detectedResolution.width - (source.pos.x || 0);
                                obsLayerHeight = detectedResolution.height - (source.pos.y || 0);
                                console.log(`使用推断分辨率计算尺寸: 原始分辨率${detectedResolution.width}x${detectedResolution.height}, 坐标(${source.pos.x}, ${source.pos.y}), 计算尺寸(${obsLayerWidth}, ${obsLayerHeight})`);
                            } else {
                                // 标准情况，使用当前画布分辨率计算
                                obsLayerWidth = canvasResolution.width - (source.pos.x || 0);
                                obsLayerHeight = canvasResolution.height - (source.pos.y || 0);
                            }
                            
                            // 确保宽度和高度为正值
                            obsLayerWidth = Math.max(obsLayerWidth, 100); // 最小宽度100px
                            obsLayerHeight = Math.max(obsLayerHeight, 100); // 最小高度100px
                            
                            const convertedCoords = convertObsCoordinates(
                                source.pos.x || 0, 
                                source.pos.y || 0, 
                                obsLayerWidth, 
                                obsLayerHeight,
                                detectedResolution
                            );
                            
                            // 通用的图层对象创建
                            const layerObj = {
                                sourceType: sourceType, // 保持原始类型名
                                configSource: 'obs',
                                name: source.name || `${sourceTypeNames[sourceType] || sourceType}源`,
                                layer: layerIndex++,
                                canvasOverlapRect: convertedCoords,
                                canvasOverlap: calculateOverlap(convertedCoords),
                                overlap: calculateOverlap(convertedCoords),
                                pos: source.pos
                            };
                            
                            // 动态添加所有源对象的属性
                            Object.keys(source).forEach(key => {
                                if (!['pos'].includes(key)) { // 排除已处理的字段
                                    layerObj[key] = source[key];
                                }
                            });
                            
                            // 特殊处理文件路径
                            if (source.filepath) {
                                layerObj.fileName = source.filepath.split('/').pop();
                                layerObj.filepath = source.filepath;
                            }
                            
                            parsedLayers.push(layerObj);
                            console.log(`添加图层: ${sourceType} - ${layerObj.name}, 最终坐标: (${convertedCoords[0].toFixed(2)}, ${convertedCoords[1].toFixed(2)}, ${convertedCoords[2].toFixed(2)}, ${convertedCoords[3].toFixed(2)})`);
                        } else {
                            console.log(`跳过无位置信息的源: ${sourceType} - ${source.name || 'unnamed'}`);
                        }
                    });
                } else {
                    console.log(`跳过非数组格式的字段: ${sourceType}`);
                }
            });
        }

        // 检测分辨率模式 - 支持超出画布范围的等比缩放
        function detectResolutionMode(obsSourceInfo) {
            let maxX = 0, maxY = 0;
            
            // 遍历所有配置类型，通用检查坐标
            Object.keys(obsSourceInfo).forEach(sourceType => {
                // 跳过特殊字段
                if (['otherScenes', 'auxAudioVolumn', 'desktopAudioVolumn'].includes(sourceType)) {
                    return;
                }
                
                const sourceData = obsSourceInfo[sourceType];
                
                // 检查是否为数组格式的源配置
                if (Array.isArray(sourceData)) {
                    sourceData.forEach(source => {
                        if (source.pos && typeof source.pos === 'object') {
                            maxX = Math.max(maxX, source.pos.x || 0);
                            maxY = Math.max(maxY, source.pos.y || 0);
                        }
                    });
                }
            });
            
            console.log(`检测到最大坐标: (${maxX}, ${maxY})`);
            console.log(`当前画布分辨率: ${canvasResolution.width}x${canvasResolution.height}`);
            
            // 检查是否超出当前画布范围
            if (maxX > canvasResolution.width || maxY > canvasResolution.height) {
                // 超出范围，推断原始分辨率并计算缩放比例
                let detectedWidth, detectedHeight, detectedName;
                
                // 根据最大坐标推断可能的原始分辨率
            if (maxX <= 1280 && maxY <= 720) {
                    detectedWidth = 1280; detectedHeight = 720; detectedName = '720p';
            } else if (maxX <= 1920 && maxY <= 1080) {
                    detectedWidth = 1920; detectedHeight = 1080; detectedName = '1080p';
            } else if (maxX <= 2560 && maxY <= 1440) {
                    detectedWidth = 2560; detectedHeight = 1440; detectedName = '2K';
                } else if (maxX <= 3840 && maxY <= 2160) {
                    detectedWidth = 3840; detectedHeight = 2160; detectedName = '4K';
            } else {
                    // 如果超出4K，使用动态计算
                    detectedWidth = Math.ceil(maxX / 100) * 100; // 向上取整到百位
                    detectedHeight = Math.ceil(maxY / 100) * 100;
                    detectedName = `${detectedWidth}x${detectedHeight}`;
                }
                
                console.log(`检测到坐标超出画布范围，推断原始分辨率: ${detectedWidth}x${detectedHeight} (${detectedName})`);
                
                // 计算缩放比例
                const scaleX = canvasResolution.width / detectedWidth;
                const scaleY = canvasResolution.height / detectedHeight;
                const scale = Math.min(scaleX, scaleY); // 使用较小的缩放比例保持宽高比
                
                console.log(`计算缩放比例: X轴=${scaleX.toFixed(4)}, Y轴=${scaleY.toFixed(4)}, 最终使用=${scale.toFixed(4)}`);
                
                return { 
                    width: detectedWidth, 
                    height: detectedHeight, 
                    name: detectedName,
                    scale: scale,
                    needsScaling: true
                };
            } else {
                // 未超出范围，使用标准检测逻辑
                let detectedWidth, detectedHeight, detectedName;
                
                if (maxX <= 1280 && maxY <= 720) {
                    detectedWidth = 1280; detectedHeight = 720; detectedName = '720p';
                } else if (maxX <= 1920 && maxY <= 1080) {
                    detectedWidth = 1920; detectedHeight = 1080; detectedName = '1080p';
                } else if (maxX <= 2560 && maxY <= 1440) {
                    detectedWidth = 2560; detectedHeight = 1440; detectedName = '2K';
                } else {
                    detectedWidth = 3840; detectedHeight = 2160; detectedName = '4K';
                }
                
                console.log(`坐标在画布范围内，检测分辨率: ${detectedWidth}x${detectedHeight} (${detectedName})`);
                
                return { 
                    width: detectedWidth, 
                    height: detectedHeight, 
                    name: detectedName,
                    scale: 1.0,
                    needsScaling: false
                };
            }
        }

        // 转换OBS坐标 - 支持等比缩放
        function convertObsCoordinates(x, y, sourceWidth, sourceHeight, detectedResolution) {
            if (detectedResolution.needsScaling) {
                // 需要等比缩放的情况
                console.log(`应用等比缩放: 原始坐标(${x}, ${y}), 缩放比例=${detectedResolution.scale.toFixed(4)}`);
                
                // 直接应用缩放比例到坐标
                const scaledX = x * detectedResolution.scale;
                const scaledY = y * detectedResolution.scale;
                const scaledWidth = sourceWidth * detectedResolution.scale;
                const scaledHeight = sourceHeight * detectedResolution.scale;
                
                console.log(`缩放后坐标: (${scaledX.toFixed(2)}, ${scaledY.toFixed(2)}, ${scaledWidth.toFixed(2)}, ${scaledHeight.toFixed(2)})`);
                
                return [scaledX, scaledY, scaledWidth, scaledHeight];
            } else {
                // 标准转换逻辑（通过720p基准）
            // 先转换到720p基准
            const scale720p = 720 / detectedResolution.height;
            const converted720pX = x * scale720p;
            const converted720pY = y * scale720p;
            const converted720pWidth = sourceWidth * scale720p;
            const converted720pHeight = sourceHeight * scale720p;
            
            // 再转换到当前画布分辨率
            const scaleToCanvas = canvasResolution.height / 720;
            const finalX = converted720pX * scaleToCanvas;
            const finalY = converted720pY * scaleToCanvas;
            const finalWidth = converted720pWidth * scaleToCanvas;
            const finalHeight = converted720pHeight * scaleToCanvas;
            
            return [finalX, finalY, finalWidth, finalHeight];
            }
        }

        // 计算覆盖率
        function calculateOverlap(rect) {
            const [x, y, width, height] = rect;
            const totalArea = canvasResolution.width * canvasResolution.height;
            const rectArea = width * height;
            return Math.min(rectArea / totalArea, 1);
        }

        // 显示消息
        function showMessage(message, type) {
            const messageDiv = document.getElementById('parseMessage');
            messageDiv.className = type === 'error' ? 'error-message' : 'success-message';
            messageDiv.textContent = message;
            messageDiv.style.display = 'block';
        }

        // 生成可视化层级
        function generateVisualization() {
            const overlaysContainer = document.getElementById('layerOverlays');
            overlaysContainer.innerHTML = '';

            parsedLayers.forEach((layer, index) => {
                const [x, y, width, height] = layer.canvasOverlapRect;
                const color = getLayerColor(layer.layer);
                
                // 创建叠加层元素
                const overlayDiv = document.createElement('div');
                overlayDiv.className = 'layer-overlay';
                // 使用唯一标识符：配置来源-层级
                const uniqueLayerId = `${layer.configSource}-${layer.layer}`;
                overlayDiv.setAttribute('data-layer', layer.layer);
                overlayDiv.setAttribute('data-unique-id', uniqueLayerId);
                overlayDiv.setAttribute('data-config-source', layer.configSource);
                
                // 获取图片元素和容器元素
                const gameImage = document.getElementById('gameImage');
                const gameContainer = document.getElementById('gameContainer');
                
                function calculateAndSetOverlayPosition() {
                    // 预检查：确保DOM完全稳定
                    const preCheck = {
                        containerWidth: gameContainer.offsetWidth,
                        containerHeight: gameContainer.offsetHeight,
                        imageWidth: gameImage.offsetWidth,
                        imageHeight: gameImage.offsetHeight,
                        naturalWidth: gameImage.naturalWidth,
                        naturalHeight: gameImage.naturalHeight
                    };
                    
                    console.log(`🔍 坐标计算预检查 - 图层${layer.layer}:`);
                    console.log(`  容器尺寸: ${preCheck.containerWidth}x${preCheck.containerHeight}`);
                    console.log(`  图片显示尺寸: ${preCheck.imageWidth}x${preCheck.imageHeight}`);
                    console.log(`  图片自然尺寸: ${preCheck.naturalWidth}x${preCheck.naturalHeight}`);
                    
                    // 如果任何关键尺寸为0，延迟重试
                    if (preCheck.containerWidth === 0 || preCheck.containerHeight === 0 || 
                        preCheck.imageWidth === 0 || preCheck.imageHeight === 0 ||
                        preCheck.naturalWidth === 0 || preCheck.naturalHeight === 0) {
                        console.log(`⚠️ DOM尺寸不稳定，延迟50ms重试`);
                        setTimeout(calculateAndSetOverlayPosition, 50);
                        return;
                    }
                    
                    // 获取容器尺寸
                    const containerRect = gameContainer.getBoundingClientRect();
                    const containerWidth = containerRect.width - 6; // 减去边框宽度
                    const containerHeight = containerRect.height - 6;
                    
                    // 获取图片的自然尺寸和显示尺寸
                    const naturalWidth = gameImage.naturalWidth;
                    const naturalHeight = gameImage.naturalHeight;
                    const displayWidth = gameImage.offsetWidth;
                    const displayHeight = gameImage.offsetHeight;
                    
                    // 计算图片的缩放比例
                    const scaleX = displayWidth / naturalWidth;
                    const scaleY = displayHeight / naturalHeight;
                    const scale = Math.min(scaleX, scaleY); // 使用较小的缩放比例保持宽高比
                    
                    // 计算实际显示的图片尺寸
                    const actualImageWidth = naturalWidth * scale;
                    const actualImageHeight = naturalHeight * scale;
                    
                    // 计算图片在容器中的偏移（居中显示）
                    const imageOffsetX = (containerWidth - actualImageWidth) / 2;
                    const imageOffsetY = (containerHeight - actualImageHeight) / 2;
                    
                    // 修复坐标计算逻辑：确保(0,0)坐标严格对应图片左上角
                    // 1. 将配置坐标从canvasResolution缩放到实际图片尺寸
                    const imageScaleX = actualImageWidth / canvasResolution.width;
                    const imageScaleY = actualImageHeight / canvasResolution.height;
                    
                    let scaledX = x * imageScaleX;
                    let scaledY = y * imageScaleY;
                    let scaledWidth = width * imageScaleX;
                    let scaledHeight = height * imageScaleY;
                    
                    // 特殊处理：确保(0,0)坐标严格对应图片左上角
                    const isZeroZeroCoordinate = (x === 0 && y === 0);
                    if (isZeroZeroCoordinate) {
                        scaledX = 0;
                        scaledY = 0;
                        console.log(`🎯 检测到(0,0)坐标图层，强制设置为图片左上角`);
                    }
                    
                    // 2. 确保图层不超出图片边界（关键修复）
                    // 对于非(0,0)坐标，限制左上角坐标不能小于0
                    if (!isZeroZeroCoordinate) {
                        scaledX = Math.max(0, scaledX);
                        scaledY = Math.max(0, scaledY);
                    }
                    
                    // 限制右下角坐标不能超出图片尺寸
                    const maxRight = actualImageWidth;
                    const maxBottom = actualImageHeight;
                    
                    // 检查图层右下角是否接近画布右下角（在配置坐标系统中）
                    const configRightX = x + width;
                    const configBottomY = y + height;
                    const isNearRightEdge = (canvasResolution.width - configRightX) <= 10;
                    const isNearBottomEdge = (canvasResolution.height - configBottomY) <= 10;
                    const needsBorderAdjustment = isNearRightEdge || isNearBottomEdge;
                    
                    // 边框宽度（6px虚线边框）需要的内边距
                    const borderWidth = 6;
                    const borderPadding = borderWidth + 2; // 额外2px确保边框完全可见
                    
                    // 只在需要调整时显示详细日志
                    if (needsBorderAdjustment) {
                        console.log(`🔍 图层${layer.layer}接近边界，需要边界收缩:`);
                        console.log(`  配置右下角坐标: (${configRightX}, ${configBottomY})`);
                        console.log(`  画布尺寸: ${canvasResolution.width}x${canvasResolution.height}`);
                        console.log(`  与右边距离: ${canvasResolution.width - configRightX}px`);
                        console.log(`  与底边距离: ${canvasResolution.height - configBottomY}px`);
                        console.log(`  是否接近右边: ${isNearRightEdge}`);
                        console.log(`  是否接近底边: ${isNearBottomEdge}`);
                    }
                    
                    // 如果图层右边界超出图片右边界，调整宽度
                    if (scaledX + scaledWidth > maxRight) {
                        scaledWidth = maxRight - scaledX;
                    }
                    
                    // 如果图层下边界超出图片下边界，调整高度
                    if (scaledY + scaledHeight > maxBottom) {
                        scaledHeight = maxBottom - scaledY;
                    }
                    
                    // 特殊处理：如果图层右下角接近画布边界，向内收缩确保边框可见
                    if (needsBorderAdjustment) {
                        console.log(`📐 应用边界收缩处理`);
                        
                        // 计算需要收缩的像素值（转换到图片坐标系统）
                        const shrinkPixelsX = borderPadding;
                        const shrinkPixelsY = borderPadding;
                        
                        // 从右边收缩：如果接近右边界且当前宽度会导致边框超出
                        if (isNearRightEdge && scaledX + scaledWidth + shrinkPixelsX > maxRight) {
                            const newWidth = maxRight - scaledX - shrinkPixelsX;
                            if (newWidth > 0) {
                                scaledWidth = newWidth;
                                console.log(`  🔧 右边界收缩: 宽度从 ${(scaledX + scaledWidth + shrinkPixelsX).toFixed(1)}px 调整为 ${scaledWidth.toFixed(1)}px`);
                            }
                        }
                        
                        // 从下边收缩：如果接近下边界且当前高度会导致边框超出
                        if (isNearBottomEdge && scaledY + scaledHeight + shrinkPixelsY > maxBottom) {
                            const newHeight = maxBottom - scaledY - shrinkPixelsY;
                            if (newHeight > 0) {
                                scaledHeight = newHeight;
                                console.log(`  🔧 下边界收缩: 高度从 ${(scaledY + scaledHeight + shrinkPixelsY).toFixed(1)}px 调整为 ${scaledHeight.toFixed(1)}px`);
                            }
                        }
                        
                        console.log(`  ✅ 边界收缩完成，确保边框在图片内可见`);
                        console.log(`  📏 最终图层尺寸: ${scaledWidth.toFixed(1)}x${scaledHeight.toFixed(1)}px`);
                        console.log(`  📍 最终图层范围: (${scaledX.toFixed(1)}, ${scaledY.toFixed(1)}) 到 (${(scaledX + scaledWidth).toFixed(1)}, ${(scaledY + scaledHeight).toFixed(1)})`);
                    }
                    
                    // 确保宽度和高度为正值
                    scaledWidth = Math.max(1, scaledWidth);
                    scaledHeight = Math.max(1, scaledHeight);
                    
                    // 3. 将图片坐标转换为容器坐标（加上图片在容器中的偏移）
                    const containerX = scaledX + imageOffsetX;
                    const containerY = scaledY + imageOffsetY;
                    
                    // 4. 转换为百分比位置（基于容器尺寸）
                    const leftPercent = (containerX / containerWidth * 100).toFixed(2);
                    const topPercent = (containerY / containerHeight * 100).toFixed(2);
                    const widthPercent = (scaledWidth / containerWidth * 100).toFixed(2);
                    const heightPercent = (scaledHeight / containerHeight * 100).toFixed(2);
                    
                    // 设置叠加层样式
                    overlayDiv.style.cssText = `
                        left: ${leftPercent}%;
                        top: ${topPercent}%;
                        width: ${widthPercent}%;
                        height: ${heightPercent}%;
                        border-color: ${color};
                    `;
                    
                    // 标签定位：与边框左上角对齐
                    positionLabelAtLayerOrigin(label, parseFloat(leftPercent), parseFloat(topPercent));
                    
                    console.log(`图层${layer.layer}坐标计算详情:`);
                    console.log(`  配置坐标: (${x}, ${y}, ${width}, ${height})`);
                    console.log(`  画布分辨率: ${canvasResolution.width}x${canvasResolution.height}`);
                    console.log(`  图片自然尺寸: ${naturalWidth}x${naturalHeight}`);
                    console.log(`  图片显示尺寸: ${displayWidth}x${displayHeight}`);
                    console.log(`  图片实际尺寸: ${actualImageWidth.toFixed(1)}x${actualImageHeight.toFixed(1)}`);
                    console.log(`  图片偏移: (${imageOffsetX.toFixed(1)}, ${imageOffsetY.toFixed(1)})`);
                    console.log(`  原始缩放坐标: (${(x * imageScaleX).toFixed(1)}, ${(y * imageScaleY).toFixed(1)}, ${(width * imageScaleX).toFixed(1)}, ${(height * imageScaleY).toFixed(1)})`);
                    console.log(`  边界限制后坐标: (${scaledX.toFixed(1)}, ${scaledY.toFixed(1)}, ${scaledWidth.toFixed(1)}, ${scaledHeight.toFixed(1)})`);
                    console.log(`  最终容器坐标: (${containerX.toFixed(1)}, ${containerY.toFixed(1)})`);
                    console.log(`  最终百分比: (${leftPercent}%, ${topPercent}%, ${widthPercent}%, ${heightPercent}%)`);
                    
                    // 特殊验证：(0,0)坐标应该对应图片左上角
                    if (isZeroZeroCoordinate) {
                        const alignmentErrorX = Math.abs(containerX - imageOffsetX);
                        const alignmentErrorY = Math.abs(containerY - imageOffsetY);
                        const isAligned = alignmentErrorX < 0.1 && alignmentErrorY < 0.1;
                        
                        console.log(`🔍 (0,0)坐标验证:`);
                        console.log(`  图片左上角在容器中的位置: (${imageOffsetX.toFixed(1)}, ${imageOffsetY.toFixed(1)})`);
                        console.log(`  图层左上角在容器中的位置: (${containerX.toFixed(1)}, ${containerY.toFixed(1)})`);
                        console.log(`  X轴对齐误差: ${alignmentErrorX.toFixed(3)}px`);
                        console.log(`  Y轴对齐误差: ${alignmentErrorY.toFixed(3)}px`);
                        console.log(`  是否完全对齐: ${isAligned ? '✅ 是' : '❌ 否'}`);
                        
                        // 如果对齐误差过大，强制修正
                        if (!isAligned) {
                            console.log(`🔧 检测到对齐误差过大，强制修正到图片左上角`);
                            const correctedLeftPercent = (imageOffsetX / containerWidth * 100).toFixed(2);
                            const correctedTopPercent = (imageOffsetY / containerHeight * 100).toFixed(2);
                            
                            overlayDiv.style.left = `${correctedLeftPercent}%`;
                            overlayDiv.style.top = `${correctedTopPercent}%`;
                            
                            // 同时修正标签位置
                            positionLabelAtLayerOrigin(label, parseFloat(correctedLeftPercent), parseFloat(correctedTopPercent));
                            
                            console.log(`🔧 强制修正后的位置: (${correctedLeftPercent}%, ${correctedTopPercent}%)`);
                        }
                    }
                }
                
                // 获取友好的显示名称
                let displayName = getLayerDisplayName(layer);
                
                // 创建标签
                const label = document.createElement('div');
                label.className = 'layer-label';
                label.style.color = color; // 设置文字颜色为边框颜色
                label.style.background = 'transparent'; // 透明背景
                label.textContent = `L${layer.layer}: ${displayName}`;
                
                // 给标签添加标识符，与边框保持一致
                label.setAttribute('data-layer', layer.layer);
                label.setAttribute('data-unique-id', uniqueLayerId);
                label.setAttribute('data-config-source', layer.configSource);
                
                // 添加鼠标悬停事件来显示全局详细信息
                overlayDiv.addEventListener('mouseenter', function() {
                    showGlobalLayerDetails(layer);
                });
                
                overlayDiv.addEventListener('mouseleave', function() {
                    hideGlobalLayerDetails();
                });
                
                // 不再创建和添加layer-details元素，只使用全局详细信息
                overlaysContainer.appendChild(overlayDiv);
                overlaysContainer.appendChild(label); // 将标签直接添加到容器中
                
                // 等待图片加载完成后再计算位置
                function ensureCalculatePosition() {
                    // 增强的稳定性检查
                    const isImageReady = gameImage.complete && gameImage.naturalWidth > 0;
                    const isDOMReady = gameImage.offsetWidth > 0 && gameImage.offsetHeight > 0;
                    const isContainerReady = gameContainer.offsetWidth > 0 && gameContainer.offsetHeight > 0;
                    
                    console.log(`🔍 DOM稳定性检查:`);
                    console.log(`  图片加载完成: ${isImageReady}`);
                    console.log(`  图片尺寸可用: ${isDOMReady} (${gameImage.offsetWidth}x${gameImage.offsetHeight})`);
                    console.log(`  容器尺寸可用: ${isContainerReady} (${gameContainer.offsetWidth}x${gameContainer.offsetHeight})`);
                    
                    if (isImageReady && isDOMReady && isContainerReady) {
                        // 所有条件满足，但仍然延迟一小段时间确保CSS完全应用
                        setTimeout(() => {
                            console.log(`🎯 开始计算图层${layer.layer}的坐标位置`);
                    calculateAndSetOverlayPosition();
                        }, 50); // 50ms延迟确保CSS稳定
                } else {
                        // 如果还没准备好，再次检查
                        setTimeout(ensureCalculatePosition, 20);
                    }
                }
                
                // 无论图片状态如何，都使用增强的检查逻辑
                ensureCalculatePosition();
                
                // 同时保留原有的load事件作为备用
                if (!gameImage.complete) {
                    gameImage.onload = function() {
                        console.log(`📸 图片load事件触发，准备重新计算`);
                        setTimeout(ensureCalculatePosition, 30);
                    };
                }
            });
        }

        // 标签定位函数 - 与图片坐标系统对齐，边框(0,0)对应图片左上角
        function positionLabelAtLayerOrigin(label, leftPercent, topPercent) {
            // 标签使用与边框相同的坐标系统，完全基于图片坐标
            // leftPercent 和 topPercent 是边框在容器中的百分比位置
            label.style.left = `${leftPercent}%`;
            label.style.top = `${topPercent}%`;
            label.style.position = 'absolute';
            label.style.zIndex = '20'; // 确保标签在最上层
            label.style.transform = 'translate(0, 0)'; // 确保没有额外的偏移
            label.style.margin = '0'; // 移除任何边距
            label.style.padding = '4px 6px'; // 保持内边距
            
            console.log(`标签定位到图层边框左上角: (${leftPercent}%, ${topPercent}%)`);
        }

        // 获取图层显示名称
        function getLayerDisplayName(layer) {
            // 对于进程类型，无论是伴侣配置还是OBS配置，都尝试查找标签
            if (layer.sourceType === 'process' && layer.exeName) {
                // 去掉扩展名，转换为小写
                const exeBase = layer.exeName.replace(/\.[^/.]+$/, '').toLowerCase();
                
                console.log(`🔍 查找进程标签: ${layer.exeName} -> ${exeBase}`);
                
                if (isProcessLibraryLoaded && processLabelMap[exeBase]) {
                    const label = processLabelMap[exeBase];
                    console.log(`✅ 找到进程标签: ${exeBase} -> ${label}`);
                    return label;
                } else {
                    console.log(`❌ 未找到进程标签: ${exeBase}, 进程库已加载: ${isProcessLibraryLoaded}`);
                    // 调试信息：显示进程库中的相关条目
                    if (isProcessLibraryLoaded) {
                        const similarKeys = Object.keys(processLabelMap).filter(key => 
                            key.includes(exeBase) || exeBase.includes(key)
                        );
                        console.log(`🔍 进程库中相似的键: ${similarKeys.join(', ')}`);
                    }
                }
                
                // 进程库找不到则用原始进程名
                return layer.exeName;
            }
            
            // 对于OBS配置，优先显示name字段
            if (layer.configSource === 'obs') {
                if (layer.name && layer.name.trim()) {
                    return layer.name;
                }
            }
            
            // 其他类型保持原有逻辑
            return layer.name || layer.sourceType;
        }

        // 生成详细信息HTML - 通用版本
        function generateDetailsHTML(layer) {
            let html = `<div><strong>类型:</strong> ${sourceTypeNames[layer.sourceType] || layer.sourceType}</div>`;
            html += `<div><strong>层级:</strong> 第${layer.layer}层</div>`;
            
            // 动态显示所有属性，按重要性排序
            const priorityFields = ['exeName', 'fileName', 'filepath', 'deviceId', 'name', 'id'];
            const skipFields = ['sourceType', 'configSource', 'layer', 'canvasOverlapRect', 'canvasOverlap', 'overlap', 'pos', 'realDeviceId'];
            
            // 先显示优先级高的字段
            priorityFields.forEach(field => {
                if (layer[field] !== undefined && layer[field] !== null && layer[field] !== '') {
                    const value = field === 'exeName' ? (layer[field].split(':').pop() || layer[field]) : layer[field];
                    const label = getFieldLabel(field);
                    html += `<div><strong>${label}:</strong> ${value}</div>`;
                }
            });
            
            // 特殊处理：对于摄像头设备，显示设备ID而不是真实设备ID
            if (layer.sourceType === 'camera' && layer.realDeviceId) {
                html += `<div><strong>设备ID:</strong> ${layer.deviceId || layer.realDeviceId}</div>`;
            }
            
            // 显示覆盖率信息
            if (layer.canvasOverlap !== undefined) html += `<div><strong>画面占比:</strong> ${(layer.canvasOverlap * 100).toFixed(1)}%</div>`;
            if (layer.overlap !== undefined) html += `<div><strong>原始占比:</strong> ${(layer.overlap * 100).toFixed(1)}%</div>`;
            
            // 显示其他所有字段
            Object.keys(layer).forEach(field => {
                if (!priorityFields.includes(field) && !skipFields.includes(field) && layer[field] !== undefined && layer[field] !== null && layer[field] !== '') {
                    const value = formatFieldValue(field, layer[field]);
                    const label = getFieldLabel(field);
                    html += `<div><strong>${label}:</strong> ${value}</div>`;
                }
            });
            
            // 显示坐标信息
            if (layer.configSource === 'obs' && layer.pos) {
                // OBS配置：显示原始坐标，宽高用"/"表示（因为缺失右下角坐标信息）
                html += `<div><strong>坐标:</strong> (${layer.pos.x || 0}, ${layer.pos.y || 0}, /, /)</div>`;
            } else {
                // 其他配置：显示完整的转换后坐标
            const [x, y, width, height] = layer.canvasOverlapRect;
            html += `<div><strong>坐标:</strong> (${Math.round(x)}, ${Math.round(y)}, ${Math.round(width)}, ${Math.round(height)})</div>`;
            }
            
            return html;
        }
        
        // 获取字段标签
        function getFieldLabel(field) {
            const fieldLabels = {
                'exeName': '进程',
                'fileName': '文件',
                'filepath': '文件路径',
                'deviceId': '设备ID',
                'name': '名称',
                'id': 'ID',
                'volume': '音量',
                'fileSize': '文件大小',
                'looping': '循环播放',
                'realDeviceId': '真实设备ID',
                'isSoftware': '软件设备',
                'decibel': '音量分贝'
            };
            return fieldLabels[field] || field;
        }
        
        // 格式化字段值
        function formatFieldValue(field, value) {
            switch (field) {
                case 'volume':
                    return value === 0 ? '静音' : `${(value * 100).toFixed(0)}%`;
                case 'fileSize':
                    return formatFileSize(value);
                case 'looping':
                case 'isSoftware':
                    return value ? '是' : '否';
                default:
                    return value;
            }
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // 生成图层列表
        function generateLayerList() {
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '';
            
            // 按配置来源分组
            const douyinLayers = parsedLayers.filter(layer => layer.configSource === 'douyin');
            const obsLayers = parsedLayers.filter(layer => layer.configSource === 'obs');
            
            // 添加"显示全部"选项
            const showAllItem = document.createElement('div');
            showAllItem.className = 'layer-item show-all selected';
            showAllItem.setAttribute('data-layer', 'all');
            showAllItem.onclick = () => showAllLayers(showAllItem);
            showAllItem.innerHTML = `
                <div class="layer-color-dot" style="background: linear-gradient(45deg, ${Object.values(layerColors).slice(0, parsedLayers.length).join(', ')});"></div>
                <div class="layer-text">
                    <div class="layer-title">🔄 显示全部图层</div>
                    <div class="layer-desc">查看所有${parsedLayers.length}个图层的叠加效果</div>
                </div>
            `;
            layerList.appendChild(showAllItem);
            
            // 先显示伴侣配置
            if (douyinLayers.length > 0) {
                const douyinGroupHeader = document.createElement('div');
                douyinGroupHeader.className = 'config-group-header douyin';
                douyinGroupHeader.innerHTML = `
                    <div class="group-icon douyin-icon">伴</div>
                    <span>伴侣配置 (${douyinLayers.length}层)</span>
                `;
                layerList.appendChild(douyinGroupHeader);
                
                // 添加伴侣配置的图层
                douyinLayers.forEach(layer => {
                    const layerItem = createLayerItem(layer);
                    layerList.appendChild(layerItem);
                });
            }
            
            // 再显示OBS配置
            if (obsLayers.length > 0) {
                const obsGroupHeader = document.createElement('div');
                obsGroupHeader.className = 'config-group-header obs';
                obsGroupHeader.innerHTML = `
                    <div class="group-icon obs-icon">OBS</div>
                    <span>OBS配置 (${obsLayers.length}层)</span>
                `;
                layerList.appendChild(obsGroupHeader);
                
                // 添加OBS配置的图层
                obsLayers.forEach(layer => {
                    const layerItem = createLayerItem(layer);
                    layerList.appendChild(layerItem);
                });
            }
        }

        // 创建图层项元素
        function createLayerItem(layer) {
            const layerItem = document.createElement('div');
            layerItem.className = 'layer-item';
            const uniqueLayerId = `${layer.configSource}-${layer.layer}`;
            layerItem.setAttribute('data-layer', layer.layer);
            layerItem.setAttribute('data-unique-id', uniqueLayerId);
            layerItem.setAttribute('data-config-source', layer.configSource);
            layerItem.onclick = () => showSingleLayer(layerItem, uniqueLayerId);
            
            const color = getLayerColor(layer.layer);
            const desc = generateLayerDescription(layer);
            
            // 添加配置来源标识
            const sourceLabel = layer.configSource === 'douyin' ? '抖音' : 'OBS';
            
            // 获取友好的显示名称
            const displayName = getLayerDisplayName(layer);
            
            layerItem.innerHTML = `
                <div class="layer-color-dot" style="background: ${color};"></div>
                <div class="layer-text">
                    <div class="layer-title" style="color: ${color};">第${layer.layer}层 - ${displayName}</div>
                    <div class="layer-desc">[${sourceLabel}] ${desc}</div>
                </div>
            `;
            
            return layerItem;
        }

        // 生成图层描述
        function generateLayerDescription(layer) {
            // 描述中保留原始的源类型信息 - 对于iosWirelessProjection保持原始名称
            let desc;
            if (layer.sourceType === 'iosWirelessProjection') {
                // 特殊处理：iosWirelessProjection在描述中保持原始名称
                desc = layer.sourceType;
            } else {
                // 其他源类型使用中文映射
                desc = `${sourceTypeNames[layer.sourceType] || layer.sourceType}`;
            }
            
            // 添加特殊信息 - 保持原始进程信息不变
            if (layer.exeName) {
                const processName = layer.exeName.split(':').pop() || layer.exeName;
                // 直接显示原始进程名，不进行进程匹配替换
                desc += ` | ${processName}`;
            }
            
            // 对于摄像头设备，优先显示deviceId
            if (layer.sourceType === 'camera' && layer.deviceId) {
                desc += ` | ${layer.deviceId}`;
            }
            
            // 对于OBS配置，优先显示文件名而不是完整路径
            if (layer.configSource === 'obs') {
                if (layer.fileName) {
                    desc += ` | ${layer.fileName}`;
                } else if (layer.filepath) {
                    // 如果没有fileName但有filepath，提取文件名
                    const fileName = layer.filepath.split('/').pop().split('\\').pop();
                    desc += ` | ${fileName}`;
                }
            } else {
                // 非OBS配置保持原有逻辑
                if (layer.fileName) {
                    desc += ` | ${layer.fileName}`;
                }
            }
            
            if (layer.fileSize) {
                desc += ` | ${formatFileSize(layer.fileSize)}`;
            }
            if (layer.volume !== undefined) {
                const volumeText = layer.volume === 0 ? '静音' : `音量${(layer.volume * 100).toFixed(0)}%`;
                desc += ` | ${volumeText}`;
            }
            
            if (layer.canvasOverlap !== undefined) {
                desc += ` | 画面占比: ${(layer.canvasOverlap * 100).toFixed(1)}%`;
            }
            
            // 坐标显示逻辑：OBS配置显示原始坐标，其他配置显示完整坐标
            if (layer.configSource === 'obs' && layer.pos) {
                // OBS配置：显示原始坐标，宽高用"/"表示（因为缺失右下角坐标信息）
                desc += ` | 坐标: (${layer.pos.x || 0}, ${layer.pos.y || 0}, /, /)`;
            } else {
                // 其他配置：显示完整的转换后坐标
            const [x, y, width, height] = layer.canvasOverlapRect;
            desc += ` | 坐标: (${Math.round(x)}, ${Math.round(y)}, ${Math.round(width)}, ${Math.round(height)})`;
            }
            
            return desc;
        }

        // 显示所有图层
        function showAllLayers(element) {
            currentSelectedLayer = 'all';
            updateSelectedItem(element);
            
            // 显示所有边框
            const overlays = document.querySelectorAll('.layer-overlay');
            overlays.forEach(overlay => {
                overlay.classList.remove('hidden');
            });
            
            // 显示所有标签
            const labels = document.querySelectorAll('.layer-label');
            labels.forEach(label => {
                label.classList.remove('hidden');
            });
        }

        // 显示单个图层
        function showSingleLayer(element, uniqueLayerId) {
            currentSelectedLayer = uniqueLayerId;
            updateSelectedItem(element);
            
            // 控制边框的显示/隐藏
            const overlays = document.querySelectorAll('.layer-overlay');
            overlays.forEach(overlay => {
                const overlayUniqueId = overlay.getAttribute('data-unique-id');
                if (overlayUniqueId === uniqueLayerId) {
                    overlay.classList.remove('hidden');
                } else {
                    overlay.classList.add('hidden');
                }
            });
            
            // 控制标签的显示/隐藏
            const labels = document.querySelectorAll('.layer-label');
            labels.forEach(label => {
                const labelUniqueId = label.getAttribute('data-unique-id');
                if (labelUniqueId === uniqueLayerId) {
                    label.classList.remove('hidden');
                } else {
                    label.classList.add('hidden');
                }
            });
        }

        // 更新选中项样式
        function updateSelectedItem(selectedElement) {
            const items = document.querySelectorAll('.layer-item');
            items.forEach(item => item.classList.remove('selected'));
            selectedElement.classList.add('selected');
        }

        // 清除可视化
        function clearVisualization() {
            document.getElementById('layerOverlays').innerHTML = '';
            const layerList = document.getElementById('layerList');
            layerList.innerHTML = '<div class="placeholder-message">请先上传底图并输入JSON配置，然后点击"解析配置"按钮</div>';
        }

        // 更新透明度
        function updateOpacity(value) {
            // 控制边框透明度
            const overlays = document.querySelectorAll('.layer-overlay:not(.hidden)');
            overlays.forEach(overlay => {
                overlay.style.opacity = value;
            });
            
            // 控制标签透明度
            const labels = document.querySelectorAll('.layer-label:not(.hidden)');
            labels.forEach(label => {
                label.style.opacity = value;
            });
            
            document.getElementById('opacityValue').textContent = Math.round(value * 100) + '%';
        }

        // 切换层级显示
        function toggleLayers() {
            const overlays = document.getElementById('layerOverlays');
            const btn = document.getElementById('layerToggle');
            if (overlays.style.display === 'none') {
                overlays.style.display = 'block';
                btn.textContent = '隐藏层级叠加';
                btn.classList.add('active');
            } else {
                overlays.style.display = 'none';
                btn.textContent = '显示层级叠加';
                btn.classList.remove('active');
            }
        }

        // 切换详细信息显示
        function toggleDetails() {
            // 由于现在使用全局详细信息，这个函数不再需要操作
            // 详细信息的显示完全由鼠标悬停和图层选择状态控制
            console.log('详细信息显示由鼠标悬停和图层选择状态自动控制');
        }

        // 拖拽上传功能
        const container = document.getElementById('gameContainer');
        container.addEventListener('dragover', function(e) {
            e.preventDefault();
            container.style.border = '3px solid #007bff';
        });
        
        container.addEventListener('dragleave', function(e) {
            container.style.border = '3px solid #333';
        });
        
        container.addEventListener('drop', function(e) {
            e.preventDefault();
            container.style.border = '3px solid #333';
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                const file = files[0];
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        document.getElementById('gameImage').src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            }
        });

        // 生成资源特征表格
        async function generateResourceFeatures(data) {
            const container = document.getElementById('resourceTableContainer');
            
            // 确保进程库已加载
            if (processLibrary.length === 0) {
                console.log('进程库未加载，正在加载...');
                await loadProcessLibrary();
            }
            
            let cpuTopProcesses = [];
            let gpuTopProcesses = [];
            
            // 解析CPU进程列表 - 字段已标准化为List格式
            if (data.cpuTopProcessList) {
                try {
                    const allCpuProcesses = JSON.parse(data.cpuTopProcessList);
                    cpuTopProcesses = allCpuProcesses.slice(0, 5); // 只保留前5个
                } catch (e) {
                    console.warn('无法解析cpuTopProcessList:', e);
                }
            }
            
            // 解析GPU进程列表 - 字段已标准化为List格式
            if (data.gpuTopProcessList) {
                try {
                    const allGpuProcesses = JSON.parse(data.gpuTopProcessList);
                    gpuTopProcesses = allGpuProcesses.slice(0, 5); // 只保留前5个
                } catch (e) {
                    console.warn('无法解析gpuTopProcessList:', e);
                }
            }
            
            if (cpuTopProcesses.length === 0 && gpuTopProcesses.length === 0) {
                container.innerHTML = '<div class="empty-state">暂无资源信息，请解析包含进程数据的配置</div>';
                return;
            }
            
            // 计算最大进程数，决定表格列数（最多5个进程）
            const maxProcessCount = Math.max(cpuTopProcesses.length, gpuTopProcesses.length);
            const totalColumns = maxProcessCount * 3; // 每个进程3列：进程名、标签、占比
            
            // 根据进程数量决定表格样式类
            const tableClass = maxProcessCount >= 5 ? 'resource-table five-processes' : 'resource-table';
            
            let tableHTML = `
                <table class="${tableClass}" style="table-layout: fixed;">
                    <thead>
                        <tr>
                            <th style="width: 8%;">资源类型</th>
            `;
            
            // 重新设计列宽分配：进程名占更多空间，标签和占比占较少空间
            const processNameWidth = `${92 / maxProcessCount * 0.5}%`; // 每个进程名占50%的进程空间
            const tagWidth = `${92 / maxProcessCount * 0.3}%`; // 每个标签占30%的进程空间
            const percentageWidth = `${92 / maxProcessCount * 0.2}%`; // 每个占比占20%的进程空间
            
            for (let i = 0; i < maxProcessCount; i++) {
                tableHTML += `
                            <th style="width: ${processNameWidth};">进程名${i + 1}</th>
                            <th style="width: ${tagWidth};">标签${i + 1}</th>
                            <th style="width: ${percentageWidth};">占比${i + 1}</th>
                `;
            }
            
            tableHTML += `
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // 添加CPU进程行
            if (cpuTopProcesses.length > 0) {
                tableHTML += `<tr><td class="process-type">CPU占用TOP</td>`;
                
                for (let i = 0; i < maxProcessCount; i++) {
                    if (i < cpuTopProcesses.length) {
                        const process = cpuTopProcesses[i];
                        console.log(`正在匹配CPU进程: ${process.name}`);
                        const processTypes = matchProcessType(process.name);
                        console.log(`CPU进程 ${process.name} 匹配结果: ${processTypes.join(', ')}`);
                        const tagHTML = generateTagHTML(processTypes);
                        
                        // 不再截断进程名，允许完整显示并换行
                        const displayName = process.name;
                        
                        tableHTML += `
                            <td class="process-name" title="${process.name}">${displayName}</td>
                            <td class="process-tag">${tagHTML}</td>
                            <td class="process-percentage">${process.percentage}%</td>
                        `;
                    } else {
                        // 空白列
                        tableHTML += `
                            <td class="process-empty">-</td>
                            <td class="process-empty">-</td>
                            <td class="process-empty">-</td>
                        `;
                    }
                }
                
                tableHTML += `</tr>`;
            }
            
            // 添加GPU进程行
            if (gpuTopProcesses.length > 0) {
                tableHTML += `<tr><td class="process-type">GPU占用TOP</td>`;
                
                for (let i = 0; i < maxProcessCount; i++) {
                    if (i < gpuTopProcesses.length) {
                        const process = gpuTopProcesses[i];
                        console.log(`正在匹配GPU进程: ${process.name}`);
                        const processTypes = matchProcessType(process.name);
                        console.log(`GPU进程 ${process.name} 匹配结果: ${processTypes.join(', ')}`);
                        const tagHTML = generateTagHTML(processTypes);
                        
                        // 不再截断进程名，允许完整显示并换行
                        const displayName = process.name;
                        
                        tableHTML += `
                            <td class="process-name" title="${process.name}">${displayName}</td>
                            <td class="process-tag">${tagHTML}</td>
                            <td class="process-percentage">${process.percentage}%</td>
                        `;
                    } else {
                        // 空白列
                        tableHTML += `
                            <td class="process-empty">-</td>
                            <td class="process-empty">-</td>
                            <td class="process-empty">-</td>
                        `;
                    }
                }
                
                tableHTML += `</tr>`;
            }
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            // 检测特定风险类型
            const riskDetectionHTML = generateRiskDetection(cpuTopProcesses);
            
            // 生成音量设置检测结果
            const audioSettingsHTML = generateAudioSettings(data);
            
            container.innerHTML = tableHTML + riskDetectionHTML + audioSettingsHTML;
            
            // 添加调试信息
            console.log(`资源特征表格生成完成: CPU进程${cpuTopProcesses.length}个, GPU进程${gpuTopProcesses.length}个, 最大进程数${maxProcessCount}`);
            console.log(`进程库状态: 共${processLibrary.length}条记录`);
        }
        
        // 生成风险进程检测结果
        function generateRiskDetection(cpuTopProcesses) {
            if (cpuTopProcesses.length === 0) {
                return ''; // 没有CPU进程数据时不显示检测结果
            }
            
            // 收集所有CPU进程的标签
            let allCpuTags = [];
            cpuTopProcesses.forEach(process => {
                const processTypes = matchProcessType(process.name);
                allCpuTags = allCpuTags.concat(processTypes);
            });
            
            // 检测各种风险类型
            const hasHumanVerification = allCpuTags.includes('人机校验作弊进程');
            const hasAIAudio = allCpuTags.includes('音频录制AI互动进程');
            const hasAutoScript = allCpuTags.includes('自动操作脚本');
            const hasDanmuCrawler = allCpuTags.includes('弹幕爬取进程');
            const hasBlackProduct = allCpuTags.includes('黑产进程');
            
            console.log('风险检测结果:', {
                '人机校验软件': hasHumanVerification,
                'AI音频软件': hasAIAudio,
                '自动操作脚本': hasAutoScript,
                '弹幕爬取软件': hasDanmuCrawler,
                '黑产进程': hasBlackProduct,
                '检测到的标签': allCpuTags
            });
            
            return `
                <div style="margin-top: 20px; padding: 15px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; border-left: 4px solid #dc3545;">
                    <div style="font-weight: bold; font-size: 16px; color: #dc3545; margin-bottom: 10px;">🔍 风险进程检测</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 30px; font-size: 14px; color: #495057;">
                        <div><strong>人机校验软件:</strong> <span style="color: ${hasHumanVerification ? '#dc3545' : '#28a745'}; font-weight: bold;">${hasHumanVerification ? '是' : '否'}</span></div>
                        <div><strong>AI音频软件:</strong> <span style="color: ${hasAIAudio ? '#dc3545' : '#28a745'}; font-weight: bold;">${hasAIAudio ? '是' : '否'}</span></div>
                        <div><strong>自动操作脚本:</strong> <span style="color: ${hasAutoScript ? '#dc3545' : '#28a745'}; font-weight: bold;">${hasAutoScript ? '是' : '否'}</span></div>
                        <div><strong>弹幕爬取软件:</strong> <span style="color: ${hasDanmuCrawler ? '#dc3545' : '#28a745'}; font-weight: bold;">${hasDanmuCrawler ? '是' : '否'}</span></div>
                        <div><strong>黑产进程:</strong> <span style="color: ${hasBlackProduct ? '#dc3545' : '#28a745'}; font-weight: bold;">${hasBlackProduct ? '是' : '否'}</span></div>
                    </div>
                </div>
            `;
        }
        
        // 生成音量设置检测结果
        function generateAudioSettings(data) {
            console.log('🎵 开始处理音量设置数据');
            console.log('🎵 pcSpeakerDecibel:', data.pcSpeakerDecibel);
            console.log('🎵 micDecibleList:', data.micDecibleList);
            
            // 检查是否有音量相关数据
            if (!data.pcSpeakerDecibel && !data.micDecibleList) {
                console.log('🎵 未找到音量设置数据');
                return ''; // 没有音量数据时不显示
            }
            
            let systemVolumeDisplay = '<span class="muted">无输入</span>';
            let micVolumeDisplay = '<span class="muted">无输入</span>';
            
            // 处理系统音量设置
            if (data.pcSpeakerDecibel !== undefined && data.pcSpeakerDecibel !== null) {
                const systemVolume = parseFloat(data.pcSpeakerDecibel);
                if (systemVolume < -900) {
                    systemVolumeDisplay = '<span class="muted">完全静音</span>';
                } else {
                    systemVolumeDisplay = `${systemVolume.toFixed(2)} dB`;
                }
                console.log('🎵 系统音量处理结果:', systemVolumeDisplay);
            }
            
            // 处理麦克风音量设置
            if (data.micDecibleList) {
                try {
                    const micVolumeArray = JSON.parse(data.micDecibleList);
                    console.log('🎵 解析的麦克风音量数组:', micVolumeArray);
                    
                    if (Array.isArray(micVolumeArray) && micVolumeArray.length > 0) {
                        // 计算平均值
                        const numericValues = micVolumeArray.filter(val => typeof val === 'number' && !isNaN(val));
                        if (numericValues.length > 0) {
                            const average = numericValues.reduce((sum, val) => sum + val, 0) / numericValues.length;
                            
                            if (average < -900) {
                                micVolumeDisplay = '<span class="muted">完全静音</span>';
                            } else if (average < -40) {
                                micVolumeDisplay = `<span class="muted">几乎无声音（${average.toFixed(2)} dB）</span>`;
                            } else {
                                micVolumeDisplay = `${average.toFixed(2)} dB (平均值)`;
                            }
                            console.log('🎵 麦克风音量处理结果:', micVolumeDisplay, '数组长度:', numericValues.length);
                        }
                    }
                } catch (e) {
                    console.warn('🎵 无法解析micDecibleList:', e);
                }
            }
            
            return `
                <div class="audio-settings">
                    <div class="audio-settings-title">🎵 直播音量设置</div>
                    <div class="audio-settings-content">
                        <div class="audio-setting-item">
                            <div class="audio-setting-label">系统音量设置:</div>
                            <div class="audio-setting-value">${systemVolumeDisplay}</div>
                        </div>
                        <div class="audio-setting-item">
                            <div class="audio-setting-label">麦克风音量设置:</div>
                            <div class="audio-setting-value">${micVolumeDisplay}</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // 窗口大小变化时重新计算叠加层位置
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                if (parsedLayers.length > 0) {
                    console.log('窗口大小变化，重新计算叠加层位置');
                    generateVisualization();
                }
            }, 250); // 防抖，250ms后执行
        });
        
        // 图片加载完成时重新计算叠加层位置
        document.getElementById('gameImage').addEventListener('load', function() {
            if (parsedLayers.length > 0) {
                console.log('图片加载完成，重新计算叠加层位置');
                setTimeout(() => {
                    generateVisualization();
                }, 100); // 稍微延迟确保图片完全渲染
            }
        });

        // 显示全局详细信息
        function showGlobalLayerDetails(layer) {
            // 只有在选择单个图层时才显示详细信息，显示全部图层时不显示
            if (currentSelectedLayer === 'all') {
                return; // 显示全部图层时，不显示详细信息
            }
            
            // 检查当前选择的图层是否与悬停的图层匹配
            const uniqueLayerId = `${layer.configSource}-${layer.layer}`;
            if (currentSelectedLayer !== uniqueLayerId) {
                return; // 只有当前选择的图层才显示详细信息
            }
            
            const globalDetails = document.getElementById('globalLayerDetails');
            globalDetails.innerHTML = generateDetailsHTML(layer);
            globalDetails.classList.add('show');
        }
        
        // 隐藏全局详细信息
        function hideGlobalLayerDetails() {
            const globalDetails = document.getElementById('globalLayerDetails');
            globalDetails.classList.remove('show');
        }

        // 1. 读取进程库，建立映射
        let processLabelMap = {};
        let isProcessLibraryLoaded = false;

        // 异步加载进程库
        async function loadProcessLibrary() {
            try {
                const response = await fetch('process-library.csv');
                const csv = await response.text();
                
                console.log('🔍 开始加载进程库...');
                
                csv.split('\n').slice(1).forEach(line => {
                    if (line.trim()) {
                        // 修复：只取前两个字段，忽略后面的空逗号
                        const parts = line.split(',');
                        const exe = parts[0];
                        const label = parts[1];
                        
                        if (exe && label && exe.trim() && label.trim()) {
                            const cleanExe = exe.trim().toLowerCase();
                            const cleanLabel = label.trim();
                            processLabelMap[cleanExe] = cleanLabel;
                            console.log(`📋 进程映射: ${cleanExe} -> ${cleanLabel}`);
                        }
                    }
                });
                
                isProcessLibraryLoaded = true;
                console.log(`✅ 进程库加载完成，共 ${Object.keys(processLabelMap).length} 个进程映射`);
                
                // 如果已经有解析的图层数据，重新渲染图层列表
                if (parsedLayers.length > 0) {
                    console.log('🔄 进程库加载完成，重新渲染图层列表...');
                    generateLayerList();
                }
                
            } catch (error) {
                console.error('❌ 加载进程库失败:', error);
            }
        }

        // 页面加载时开始加载进程库
        loadProcessLibrary();

        // 2. 改进getLayerDisplayName函数
        function getLayerDisplayName(layer) {
            // 对于进程类型，无论是伴侣配置还是OBS配置，都尝试查找标签
            if (layer.sourceType === 'process' && layer.exeName) {
                // 去掉扩展名，转换为小写
                const exeBase = layer.exeName.replace(/\.[^/.]+$/, '').toLowerCase();
                
                console.log(`🔍 查找进程标签: ${layer.exeName} -> ${exeBase}`);
                
                if (isProcessLibraryLoaded && processLabelMap[exeBase]) {
                    const label = processLabelMap[exeBase];
                    console.log(`✅ 找到进程标签: ${exeBase} -> ${label}`);
                    return label;
                } else {
                    console.log(`❌ 未找到进程标签: ${exeBase}, 进程库已加载: ${isProcessLibraryLoaded}`);
                    // 调试信息：显示进程库中的相关条目
                    if (isProcessLibraryLoaded) {
                        const similarKeys = Object.keys(processLabelMap).filter(key => 
                            key.includes(exeBase) || exeBase.includes(key)
                        );
                        console.log(`🔍 进程库中相似的键: ${similarKeys.join(', ')}`);
                    }
                }
                
                // 进程库找不到则用原始进程名
                return layer.exeName;
            }
            
            // 对于OBS配置，优先显示name字段
            if (layer.configSource === 'obs') {
                if (layer.name && layer.name.trim()) {
                    return layer.name;
                }
            }
            
            // 其他类型保持原有逻辑
            return layer.name || layer.sourceType;
        }
    </script>
</body>
</html>